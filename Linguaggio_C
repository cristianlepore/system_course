Il C è un linguaggio procedurale, rispetto a Java non ci sono le classi. Non ci sono oggetti.
Le strutture di controllo sono uguali. For, while, if , switch.
Hello world deriva direttamente dal linguaggio C.
Come in Java ci sono i metodi statici, in C tutti i metodi sono statici e si chiamano funzioni.
Le funzioni si dichiarano scrivendo il nome del loro prototipo.
Anche qui c'è una funzione particolare che viene eseguita all'avvio del programma.
Però a differenza del Java, nel C questa funzione è in due gusti: semplice e più complessa.
Questa funzione quando termina restituisce un valore intero, anche qui.

Perchè Main restituisce un valore int?
Come fa un processo a terminare? Per poter terminare un processo deve invocare una particolare system.call che dice al OS che ha finito di fare quello che doveva. Perchè il OS deve fare una serie di operazioni in system call che l'utente non può fare. Es: il OS da qualche parte tiene traccia di quelli che sono tutti i processi in esecuzione. Se un processo termina ovviamente, le informazioni che il OS teneva di quel processo è inutile che le tenga ancora in memoria.

Quando un processo termina, può farlo in 2 modi:
1- termina bene --> ha terminato di fare quello che il processo doveva fare.
2- termina male --> es c'è un baco nel programma e provate ad accedere ad una locazione di memoria a cui non vi è consentito accedere. es. fate una divisione per zero.

Il valore che restituisce la funzione main permette al OS di capire se la terminazione è avvenuta per cause naturali o per morte violenta.
Si usa una convenzione. Es. se termina con 0 significa per convenzione che il processo è morto per morte naturale, altrimenti se il processo muore per morte anomala la maggior parte delle volte ce ne rendiamo conto da soli. Comunque se abbiamo un numero superiore a zero, significa che il processo è terminato con un errore ed il numero ci fornisce un'indicazione del tipo di errore. Spesso non ci interessa sapere qual'è il valore con cui un processo termina.

E' prassi comune quando si lavora con il terminale scrivere l'equivalente di altri programmi. Es. automatizzano le operazioni del terminale.
L'interprete del nostro terminale (shell) C è in grado di leggere il contenuto di un file testuale ed interpretarlo come un programma dove ci sono anche strutture di controllo.

Possiamo anche eseguire processi utente.
Quando scriviamo questi programmi, sapere se sono terminati bene o male, può essere un'informazione rilevante.
Perchè quando dobbiamo eseguire due programmi subordinati, la possibilità di eseguire il primo è subordinata alla correttezza del secondo. Quini solo se il primo ha restituito zero.

Il compilatore C è più permissivo rispetto al compilatore Java. Es. se proviamo ad accedere ad un elemento di un array e questo non esiste, in Java se la dimensione dell'array è nota staticamente, il compilatore se ne accorge. Il C non è cosi preciso. Es. se assegniamo ad una variabile intera un valore non intero, in Java il compilatore si lamenta, mentre in C no. Perchè il C è pensato per linguaggi a  basso livello. Anche durante l'esecuzione. Stampa solo il messaggio: segmentation fault.

La funzione printf non è un construtto del linguaggio, ma deve essere importata. Come? Con una sintassi: #include <stdio.h>

E' scritto cosi perchè neli anni 70 non avevano molto spazio su disco e risparmiare caratteri faceva la differenza.
Il fatto che include abbia davanti un cancellatto significa che se ne prende a carico il pre-processore che non fa altro che scandire il testo di un sorgente prima di darlo in pasto al compilatore. In realtà questo pre-processore non fa altro che includere delle librerie e definire delle costanti.

Librerie: <stdio.h> aver usato < e > significa che il file si trova in una particolare directory di sistema e non nella stessa directory del sorgente che vado a scrivere, perchè è una directory standard.

Cosa contiene stdio.h???
Contiene tanti prototipi di funzione. Es: soltanto int main con il numero corretto di paramentri, etc..
Come con Java quando dichiariamo una interfaccia. Scriviamo solo l'interstazione del metodo e non il suo corpo.

Cosa succederebbe se io non importassi il file <stdio.h>??
Il compilatore vede che io sto usando una funzione che non ho mai dichiarato prima, ne importato con una ilbreria. Il compilatore immagina che quella funzione non ha argomenti e restituisce un int, un po' come main. Però io non sto usando printf in quel modo, quindi il compilatore si lamenterà.

Perchè si chiama printf? f sta per formatted
Questa funzione si occupa di stampare la stringa a video e di mescolare delle stringhe con eventualmente espressioni numeriche o di altro tipo.
In Java abbiamo la dualità print e printline, invece in C abbiamo solo printf e poi dobbiamo aggiungergi il carattere di a capo.
\n e \t e \\ sono le più comuni.

Come si compila?
Esistono tanti compilatori C. Chi ha macchine UNIX e Windows cigWin. Il compilatore è gcc che è il progetto open source di richard stallman da cui è derivato anche Linux.
gcc nomeSorgente.c 
Se ci fermiamo qui, la compilazione viene fatta e viene creato un file dal nome a.out
Se non ci piace avere un file a.out possiamo fare
gcc -Wall nomeSorgente.c -o nome_da_dare_ad_eseguibile
Usare opzione -Wall significa attiva dei warning

Questo crea il codice oggetto da eseguire.

Non c'è ancora uno standard per la dichiarazione delle variabili. Alcuni le dichiarano prima (vecchia scuola), altri all'interno del ciclo FOR. Io seguo la vecchia scuola.

L'operatore == ha lo stesso significato che in Java. E' quell'operatore booleano che mi dice se due espressioni sono uguali.
|| è un or logico come in Java. Niente di nuovo.

Quando nella stringa di formato, cioè il printf c'è un % è un po' come se ci fosse una sequenza di escape. Il % viene ignorato e si legge il carattere successivo e quel carattere viene interpretato in modo particolare. In realtà %d è un segnaposto che indica un punto preciso in cui dovrò stampare il valore di una espressione. Il %d significa che poi vuole una espressione intera che verrà specificata come argomento di printf.
Quindi printf ha un numero variabile di argomenti. Avrà sempre una stringa di formato che è il primo argomento e poi per ogni segnaposto avrò un numero variabile di espressioni che mi dicono come riempire quel segnaposto.

Ancora una volta il compilatore non si prende la briga di verificare che il numero di argomenti sia compatibile con il numero dei segnaposti.

Se ho un numero diverso di argomenti lo standard ci dice che dobbiamo attenderci un comportamento indefinito poichè non è normata dallo standard del C. significa che il comportamento dipende dalla scelta che il team di informatici ha fatto sviluppando il vostro particolare compilatore C. Comunque niente di buoni.

Il pre-processore può anche dichiarare delle costanti. Con l'istruzione #define. Si chiamano Macro. Per standard si definiscono come nome maiuscolo seguito ddal valore senza punto e virgola.
Cosa fa il pre-processore quando scandendo un sorgente trova define N 1000
Fa un trova e sostituisci. Se mettessimo il 1000; allora sostituirebbe N con 1000; anche il punto e virgola, dandoci molti errori.

Se non metto Return 0 il compilatore non si arrabbia.

**************************
**************************

scanf è la sorella di printf perchè vuole una stringa di formato come printf.

Come funziona scanf?
Devo specificare il tipo di valore che voglio leggere usando quello che in printf era un segnaposto.
%d è un segnaposto che vale a dire intero.
%f è un segnaposto che vale a dire numero con la virgola.
Però il valore che leggo dalla tastiera dovrò metterlo a qualche parte.
Per tutta una serie di motivi, scanf non restituisce il valore che ha letto, ma il numero di caratteri che ha letto.
Per poter andare a memorizzare quello che è stato letto devo usare il & davanti al nome della mia variabile.

Cosa significa &?
Parliamo di puntatori e riferimenti.
In Java quando instanziamo una classe o creiamo un oggetto nella JVM viene creato uno spazio per inserire tutte le variabili d'istanza (uno spazio). Come fa il programmatore a far riferimento ad un oggetto?
Ad un programmatore inesperto scrivere 
int i = 5; oppure String str = "Hello world" sembra che non ci sia una differenza.
In realtà la differenza esiste ed è notevole.
Vediamo la memoria centrale come una cassettiera. Ogni cassetto è una locazione di memoria ed ogni cassetto ha un numero che rappresenta l'indirizzo.

In Java se scrivo int i = 5;    Semplicemente nella memoria viene cercata una locazione libera per poter memorizzare un intero.
L'effetto di dichiarare una variabile intera è quello di cercare una locazione di memoria libera e da quel momento in poi la leghiamo con un doppio filo al concetto di variabile i. Quindi ogni volta che nel codice trovo i, vado a leggere in quella particolare locazione di memoria. Vale anche che se scrivo sulla variabile i, vado a scrivere in quella locazione di memoria. Una stringa non posso metterla in una sola locazione i memoria ma la macchina cercherà una sequenza di stringhe contigue.
Nella locazione di memoria memorizzerò l'indirizzo dello heap in cui metto il primo carattere della mia stringa. Cioè è un riferimento. Ovvero un indirizzo della cella di memoria nella quale ho iniziato a memorizzare qualcosa.
La stringa è memorizzata nello heap, mentre il suo riferimento è nello stack insieme alle variabili. Es. int i è nello stack insieme all'indirizzo della stringa. La stringa vera e propria è nello heap. Indirizzamento diretto nel caso della variabile. Indirizzamento indiretto con la stringa.

In C che cos'è un puntatore? E' quello che in Java viene chiamato un riferimento.
Quell'operatore &n si chiama in C operatore di referenziazione. E' un operatore unario e l'operando deve essere il nome di una variabile.
&n restituisce l'indirizzo della cella di memoria a partire dal quale quella variabile è memorizzata. Cioè non passo il valore n, ma l'indirizzo a partire dal quale n è memorizzato.
& tira fuori il puntatore alla prima cella in cui la variabile è memorizzata.

Un'altro modo di passare i parametri oltre a scanf, è da linea di comando.
argc --> il numero di elementi passati + 1 perchè il primo è il nome dell'eseguibile.
char *argc[]
dove [] come in Java sono utilizzate per gli array.
* invece ha a che vedere con i puntatori.
* ha solitamente il significato opposto all'operatore di &
* da in indirizzo o da un puntatore che dir si voglia, tira fuori la variabile corrispondente.

**************************
**************************

E' importante che voi scriviate il codice con le vostre mani per predere confidenza con gli errori che sputa fuori il terminale.

printf e scanf fanno l'output formattato. Cioè io prendo il mio testo formattato che contiene caratteri e dei segnaposto. L'alternativa è quella di leggere l'input e stampare l'output carattere per carattere.
Le funzioni che fanno questo si chiamano getchar e putchar.

getchar() --> è una funzione che non vuole argomenti e restituisce il carattere letto.
int c;
getchar(c)
Posso mettere getchar in un intero perchè alla fine un carattere sotto sotto è memorizzato come intero e c'è una tabella di conversione tra caratteri ed interi. Questa tabella di conversione è quella dello standard ASCII.
getchar() blocca l'esecuzione in attesa che premiamo un tasto. Il codice ASCII del carattere corrispondete viene restituito a getchar ed assegnato alla variabile C.

putchar(c) invece vuole un argomento e sputa fuori un carattere, non un intero o altro.

Quando usiamo getchar o putchar, avremo anche EOF. Perchè un file EOF?
Perchè in C la lettura e scrittura da standar input o output altro non è che la lettura o scrittura su un file. Niente di nuovo.
EOF --> significa ho terminato di inserire l'input.

In realtà i caratteri in C vengono trattati come interi, quindi potrei passare un intero come parametro di una fuinzione e poi all'interno della funzione trattarlo come carattere o sostituire al carattere il suo equivalente ASCII.

Un terzo modo per leggere o scrivere stringhe è puts o gets. Questi metodi però funzionano solo con stringhe ben formattate. Quindi quando le uso devo essere sicuro di conoscere l'intera stringa.

Parliamo degli Array.
Gli array in C sono come in Java, con la sola differenza che in Java c'è un supporto nel supporto degli errori nel momento in cui sto cercano di accedere ad una locazione i memoria che non esiste. Questo in C non esiste.
Dichiaro un array int a[] = {1, 6, 9, 3}; e non mi preoccupo di dire quanto è grande perchè in questo caso contestualmente alla dichiarazione, mi sono anche preoccupato di dire quanto è grande. Se non lo avessi dichiarato e contestualizzato, allora avrei dovuto anche dare la dimensione dell'array.

C'è una differenza tra gli array in Java e gli array in C. In Java gli array sono essenzialmente degli ogetti. Per esempio posso in Java posso scrivere il nome dell'array seguita dal punto e qualcosa per accedere all'elemento dell'array.

In C questo non si può fare. Quindi se vogliamo passare un array come parametro di una funzione, dobbiamo anche passargli un secondo parametro che mi dice quanto è lungo l'array.
Perchè devo specificare la lunghezza di un arrey quando passo l'array come parametro di una funzione?
Qui entrano in gioco i puntatori. Normalmente un puntatore viene interpretato come l'indirizzo di una cella di memoria a partire dalla quale viene memorizzata una variabile.
Dichiaro un puntatore cosi: int *p;
Però * assume significati diversi a seconda che io stia dichiarando un puntatore o usandolo.
Un puntatore lo interpreto come un indirizzo a partire dal quale è memorizzata una variabile.
p = 42 significa andare a leggere o scrivere nella locazione di memoria con indirizzo 42.
Questo indirizzo è gestito dal OS e per noi è trasparente.

Dobbiamo quindi assegnare dei valori ai puntatori in modo indiretto.
Se volessi far puntare il puntatore *p alla variabile i userei
int i;
int *p;
p = &i;
Questo significa dammi l'indirizzo di i e mettilo nel puntatore p.

In C per poter leggere il valore di i a partire dal puntatore p devo usare l'operatore di deferenziazione *p. Ecco quindi il secondo utilizzo di *, cioè come operatore di deferenziazione.
Quindi per stampare o lavorare con il puntatore dopo, mi basterà dereferenziarlo con *p. *p lo potrei usare in tutti i contesti in cui utilizzo una variabile.
N.B. --> nel passaggio dei parametri con una funzione, le variabili vengono passate come valore, invece gli array vengono passati come puntatori. Infatti un array ha una lunghezza varibile e non viene passata come valore, ma solo come puntatore.
Potrei infatti cambiare la dichiarazione (o prototipo) della funzione da: a[] con *a
Perchè quando viene passato un array, non passo il suo valore, ma piuttosto un puntatore alla cella a partire dal quale è memorizzato l'array.
All'interno della funzione a[i] viene trattato come un puntatore, ovvero mi dice di andare alla locazione a[0] e poi sfrutta l'aritmetica dei puntatori per muoversi tra le celle.

**************************
**************************

Aritmetica dei puntatori:
Prendiamo un'altro esempio
Se scrivo:
int a[] = {19, 23, 3}; --> dichiaro un array
int *p = a; --> qui non ho bisogno di mettere l'operatore di & davanti ad a.
Infatti ogni volta che dichiaro un arrai, poi lo posso chiamare solo con a, ed è sottointeso che abbia l'operatore & davanti.

A quel punto scrivere p[0] oppure a[0] sarà la stessa cosa.
Ovvero vado a prendere il puntatore p, leggo il suo contenuto. Il contenuto sarà l'indirizzo di memoria di dove inizia il puntatore a. Vado nella prima cella dell'array a e leggo il contenuto.
Se scrivessi p[1] andrei a prendere il contenuto del puntatore p. Il contenuto è l'indirizzo di memoria di dove inizia il puntatore a. Vado nella prima cella dell'array ed incremento di 1. Il valore che leggo è il mio valore.
Quindi p[1] = a[1]
in generale p[i] = a[i]
*a = 0; --> equivalente ad a[0] = 0;
(a+1) = 0; --> equivalente ad a[1] = 0;
Ovvero se uso il + ed uno dei suoi argomenti è un puntatore, ottengo un puntatore.
*(a+1);

Quindi in C gli array vengono passati come puntatori. Se modifico l'array nel main, lo modificherò anche nella funzione che ho chiamato.

Quando ha senso usare l'aritmetica dei puntatori?
Nel caso delle stringhe. Infatti in C le stringhe sono degli array di caratteri.
In C per convenzione le stringhe sono degli array di caratteri in cui non ho bisogno di specificarne la lunghezza perchè dopo l'ultimo carattere di una stringa ho un carattere particolare che ha codice ASCII 0. Il compilatore saprà che la stringa terminerà quando si trova codice ASCII zero.

Con s++ mi muovo tra gli elementi della stringa fino a raggiungere il carattere di terminazione.
